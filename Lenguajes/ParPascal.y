-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParPascal where
import AbsPascal
import LexPascal
import ErrM

}

%name pProgram Program
%name pBlock Block
%name pParts Parts
%name pConstants Constants
%name pListConst ListConst
%name pConst Const
%name pVal Val
%name pTypes Types
%name pListListTypes ListListTypes
%name pListTypes ListTypes
%name pType Type
%name pListListId ListListId
%name pListId ListId
%name pRangeType RangeType
%name pListLType ListLType
%name pLType LType
%name pListFields ListFields
%name pFields Fields
%name pAccessRecord AccessRecord
%name pVars Vars
%name pListListVars ListListVars
%name pListVars ListVars
%name pFuncsProcs FuncsProcs
%name pListInstruction ListInstruction
%name pInstruction Instruction
%name pSimpleInstruction SimpleInstruction
%name pListParms ListParms
%name pParms Parms
%name pListExps ListExps
%name pExps Exps
%name pFactor Factor
%name pTerms Terms
%name pSimpleExp SimpleExp
%name pAdd Add
%name pEquals Equals
%name pMinus Minus
%name pGeneralExp GeneralExp
%name pCompositeInstruction CompositeInstruction
%name pElse Else
%name pListListInstrs ListListInstrs
%name pListInstrs ListInstrs
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  '+' { PT _ (TS _ 3) }
  ',' { PT _ (TS _ 4) }
  '-' { PT _ (TS _ 5) }
  '.' { PT _ (TS _ 6) }
  '..' { PT _ (TS _ 7) }
  ':' { PT _ (TS _ 8) }
  ':=' { PT _ (TS _ 9) }
  ';' { PT _ (TS _ 10) }
  '<' { PT _ (TS _ 11) }
  '<=' { PT _ (TS _ 12) }
  '<>' { PT _ (TS _ 13) }
  '=' { PT _ (TS _ 14) }
  '>' { PT _ (TS _ 15) }
  '>=' { PT _ (TS _ 16) }
  '[' { PT _ (TS _ 17) }
  ']' { PT _ (TS _ 18) }
  '^' { PT _ (TS _ 19) }
  'array' { PT _ (TS _ 20) }
  'begin' { PT _ (TS _ 21) }
  'const' { PT _ (TS _ 22) }
  'do' { PT _ (TS _ 23) }
  'downto' { PT _ (TS _ 24) }
  'else' { PT _ (TS _ 25) }
  'end' { PT _ (TS _ 26) }
  'end.' { PT _ (TS _ 27) }
  'for' { PT _ (TS _ 28) }
  'if' { PT _ (TS _ 29) }
  'of' { PT _ (TS _ 30) }
  'program' { PT _ (TS _ 31) }
  'record' { PT _ (TS _ 32) }
  'repeat' { PT _ (TS _ 33) }
  'then' { PT _ (TS _ 34) }
  'to' { PT _ (TS _ 35) }
  'type' { PT _ (TS _ 36) }
  'until' { PT _ (TS _ 37) }
  'var' { PT _ (TS _ 38) }

L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_quoted { PT _ (TL $$) }
L_charac { PT _ (TC $$) }
L_Id { PT _ (T_Id $$) }


%%

Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
String  :: { String }  : L_quoted {  $1 }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Id    :: { Id} : L_Id { Id ($1)}

Program :: { Program }
Program : 'program' Id ';' Block { AbsPascal.PProgram $2 $4 }
Block :: { Block }
Block : Parts 'begin' ListInstruction 'end.' { AbsPascal.PBlock $1 $3 }
Parts :: { Parts }
Parts : Constants Types Vars FuncsProcs { AbsPascal.PPart $1 $2 $3 $4 }
Constants :: { Constants }
Constants : {- empty -} { AbsPascal.PPartConstEmpty }
          | 'const' ListConst { AbsPascal.PPartConst $2 }
ListConst :: { [Const] }
ListConst : {- empty -} { [] }
          | Const { (:[]) $1 }
          | Const ';' ListConst { (:) $1 $3 }
Const :: { Const }
Const : Id '=' Val { AbsPascal.PListConst $1 $3 }
Val :: { Val }
Val : Integer { AbsPascal.PValInteger $1 }
    | Double { AbsPascal.PValDouble $1 }
    | String { AbsPascal.PValString $1 }
    | Char { AbsPascal.PValChar $1 }
Types :: { Types }
Types : {- empty -} { AbsPascal.PPartTypesEmpty }
      | 'type' ListListTypes { AbsPascal.PPartTypes $2 }
ListListTypes :: { [ListTypes] }
ListListTypes : {- empty -} { [] }
              | ListTypes { (:[]) $1 }
              | ListTypes ';' ListListTypes { (:) $1 $3 }
ListTypes :: { ListTypes }
ListTypes : Id '=' Type { AbsPascal.PListTypes $1 $3 }
Type :: { Type }
Type : '(' ListListId ')' { AbsPascal.PTypeEnum $2 }
     | RangeType '..' RangeType { AbsPascal.PTypeSubRange $1 $3 }
     | '^' Id { AbsPascal.PTypePointer $2 }
     | 'array' '[' ListLType ']' 'of' Id { AbsPascal.PTypeArray $3 $6 }
     | 'record' ListFields 'end' { AbsPascal.PTypeRecord $2 }
     | Id { AbsPascal.PTypeIdentifier $1 }
ListListId :: { [ListId] }
ListListId : {- empty -} { [] }
           | ListId { (:[]) $1 }
           | ListId ',' ListListId { (:) $1 $3 }
           | {- empty -} { [] }
           | ListId { (:[]) $1 }
           | ListId ',' ListListId { (:) $1 $3 }
ListId :: { ListId }
ListId : Id { AbsPascal.PListIdEnum $1 }
       | Id { AbsPascal.PListId $1 }
RangeType :: { RangeType }
RangeType : Id { AbsPascal.PRangeTypeId $1 }
          | Char { AbsPascal.PRangeTypeChar $1 }
          | Integer { AbsPascal.PRangeTypeInteger $1 }
ListLType :: { [LType] }
ListLType : {- empty -} { [] }
          | LType { (:[]) $1 }
          | LType ',' ListLType { (:) $1 $3 }
LType :: { LType }
LType : Type { AbsPascal.PTypeArrayLType $1 }
ListFields :: { [Fields] }
ListFields : {- empty -} { [] }
           | Fields { (:[]) $1 }
           | Fields ';' ListFields { (:) $1 $3 }
Fields :: { Fields }
Fields : ListListId ':' Type { AbsPascal.PRecordFields $1 $3 }
AccessRecord :: { AccessRecord }
AccessRecord : Id '.' Id { AbsPascal.PAccessRecord $1 $3 }
Vars :: { Vars }
Vars : {- empty -} { AbsPascal.PPartVarsEmpty }
     | 'var' ListListVars { AbsPascal.PPartVars $2 }
ListListVars :: { [ListVars] }
ListListVars : {- empty -} { [] }
             | ListVars { (:[]) $1 }
             | ListVars ';' ListListVars { (:) $1 $3 }
ListVars :: { ListVars }
ListVars : ListListId ':' Id { AbsPascal.PListVars $1 $3 }
FuncsProcs :: { FuncsProcs }
FuncsProcs : {- empty -} { AbsPascal.PPartFuncsProcs }
ListInstruction :: { [Instruction] }
ListInstruction : {- empty -} { [] }
                | Instruction { (:[]) $1 }
                | Instruction ';' ListInstruction { (:) $1 $3 }
Instruction :: { Instruction }
Instruction : {- empty -} { AbsPascal.PListInstructionEmpty }
            | SimpleInstruction { AbsPascal.PListSimpleInstruction $1 }
            | CompositeInstruction { AbsPascal.PListCompositeInstruction $1 }
SimpleInstruction :: { SimpleInstruction }
SimpleInstruction : {- empty -} { AbsPascal.PSimpleInstructionEmpty }
                  | Id ':=' Exps { AbsPascal.PSimpleInstructionAssignment $1 $3 }
                  | AccessRecord ':=' Exps { AbsPascal.PSimpleInstructionAssignmentAccRecord $1 $3 }
                  | Id Parms { AbsPascal.PSimpleInstructionProcFunc $1 $2 }
ListParms :: { [Parms] }
ListParms : {- empty -} { [] }
          | Parms { (:[]) $1 }
          | Parms ',' ListParms { (:) $1 $3 }
Parms :: { Parms }
Parms : {- empty -} { AbsPascal.PParmsEmpty }
      | '(' ListExps ')' { AbsPascal.PParms $2 }
ListExps :: { [Exps] }
ListExps : {- empty -} { [] }
         | Exps { (:[]) $1 }
         | Exps ',' ListExps { (:) $1 $3 }
Exps :: { Exps }
Exps : {- empty -} { AbsPascal.PExpsEmpty }
     | Factor { AbsPascal.PExpsFactor $1 }
     | Terms { AbsPascal.PExpsTerms $1 }
     | SimpleExp { AbsPascal.PExpsSimple $1 }
     | GeneralExp { AbsPascal.PExpGeneral $1 }
Factor :: { Factor }
Factor : String { AbsPascal.PFactorString $1 }
       | Id { AbsPascal.PFactorId $1 }
       | Integer { AbsPascal.PFactorInteger $1 }
       | AccessRecord { AbsPascal.PFactorAccRecord $1 }
       | Id '(' ListExps ')' { AbsPascal.PFactorFunction $1 $3 }
Terms :: { Terms }
Terms : {- empty -} { AbsPascal.PTerms }
SimpleExp :: { SimpleExp }
SimpleExp : Add { AbsPascal.PSimpleExpAdd $1 }
          | Equals { AbsPascal.PSimpleExpEquals $1 }
          | Minus { AbsPascal.PSimpleExpMinus $1 }
Add :: { Add }
Add : Factor '+' Factor { AbsPascal.PAdd $1 $3 }
Equals :: { Equals }
Equals : Factor '=' Factor { AbsPascal.PEquals $1 $3 }
Minus :: { Minus }
Minus : Factor '-' Factor { AbsPascal.PMinus $1 $3 }
GeneralExp :: { GeneralExp }
GeneralExp : {- empty -} { AbsPascal.PGeneralExp }
           | '(' Exps '>' Exps ')' { AbsPascal.PGeneralExpMayor $2 $4 }
           | '(' Exps '<' Exps ')' { AbsPascal.PGeneralExpMinor $2 $4 }
           | '(' Exps '=' Exps ')' { AbsPascal.PGeneralExpEqual $2 $4 }
           | '(' Exps '>=' Exps ')' { AbsPascal.PGeneralExpMayorEqual $2 $4 }
           | '(' Exps '<=' Exps ')' { AbsPascal.PGeneralExpMinorEqual $2 $4 }
           | '(' Exps '<>' Exps ')' { AbsPascal.PGeneralExpDistinct $2 $4 }
CompositeInstruction :: { CompositeInstruction }
CompositeInstruction : 'if' Exps 'then' Instruction Else { AbsPascal.PCompositeInstructionIf $2 $4 $5 }
                     | 'repeat' ListListInstrs 'until' Exps { AbsPascal.PCompositeInstructionRepeat $2 $4 }
                     | 'for' Id ':=' Exps 'to' Exps 'do' Instruction { AbsPascal.PCompositeInstructionForTo $2 $4 $6 $8 }
                     | 'for' Id ':=' Exps 'downto' Exps 'do' Instruction { AbsPascal.PCompositeInstructionForDownTo $2 $4 $6 $8 }
Else :: { Else }
Else : {- empty -} { AbsPascal.PIfElseEmpty }
     | 'else' Instruction { AbsPascal.PIfElse $2 }
ListListInstrs :: { [ListInstrs] }
ListListInstrs : {- empty -} { [] }
               | ListInstrs { (:[]) $1 }
               | ListInstrs ';' ListListInstrs { (:) $1 $3 }
ListInstrs :: { ListInstrs }
ListInstrs : Instruction { AbsPascal.PRepeatListInstrs $1 }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

