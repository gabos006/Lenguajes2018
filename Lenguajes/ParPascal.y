-- This Happy file was machine-generated by the BNF converter
{
{-# OPTIONS_GHC -fno-warn-incomplete-patterns -fno-warn-overlapping-patterns #-}
module ParPascal where
import AbsPascal
import LexPascal
import ErrM

}

%name pProgram Program
%name pBlock Block
%name pListInstruction ListInstruction
%name pInstruction Instruction
%name pListParms ListParms
%name pParms Parms
%name pParts Parts
%name pConstants Constants
%name pListConst ListConst
%name pConst Const
%name pVal Val
%name pTypes Types
%name pListListTypes ListListTypes
%name pListTypes ListTypes
%name pType Type
%name pVars Vars
%name pListListVars ListListVars
%name pListVars ListVars
%name pListListId ListListId
%name pListId ListId
%name pFuncsProcs FuncsProcs
-- no lexer declaration
%monad { Err } { thenM } { returnM }
%tokentype {Token}
%token
  '(' { PT _ (TS _ 1) }
  ')' { PT _ (TS _ 2) }
  ',' { PT _ (TS _ 3) }
  '..' { PT _ (TS _ 4) }
  ':' { PT _ (TS _ 5) }
  ';' { PT _ (TS _ 6) }
  '=' { PT _ (TS _ 7) }
  '[' { PT _ (TS _ 8) }
  ']' { PT _ (TS _ 9) }
  '^' { PT _ (TS _ 10) }
  'array' { PT _ (TS _ 11) }
  'begin' { PT _ (TS _ 12) }
  'const' { PT _ (TS _ 13) }
  'end' { PT _ (TS _ 14) }
  'end.' { PT _ (TS _ 15) }
  'of' { PT _ (TS _ 16) }
  'program' { PT _ (TS _ 17) }
  'readln(' { PT _ (TS _ 18) }
  'record' { PT _ (TS _ 19) }
  'type' { PT _ (TS _ 20) }
  'var' { PT _ (TS _ 21) }
  'writeln(' { PT _ (TS _ 22) }

L_quoted { PT _ (TL $$) }
L_integ  { PT _ (TI $$) }
L_doubl  { PT _ (TD $$) }
L_charac { PT _ (TC $$) }
L_Id { PT _ (T_Id $$) }


%%

String  :: { String }  : L_quoted {  $1 }
Integer :: { Integer } : L_integ  { (read ( $1)) :: Integer }
Double  :: { Double }  : L_doubl  { (read ( $1)) :: Double }
Char    :: { Char }    : L_charac { (read ( $1)) :: Char }
Id    :: { Id} : L_Id { Id ($1)}

Program :: { Program }
Program : 'program' Id ';' Block { AbsPascal.PProgram $2 $4 }
Block :: { Block }
Block : Parts 'begin' ListInstruction 'end.' { AbsPascal.PBlock $1 $3 }
ListInstruction :: { [Instruction] }
ListInstruction : {- empty -} { [] }
                | Instruction { (:[]) $1 }
                | Instruction ';' ListInstruction { (:) $1 $3 }
Instruction :: { Instruction }
Instruction : {- empty -} { AbsPascal.PListInstructionEmpty }
            | 'writeln(' ListParms ')' { AbsPascal.PListInstructionWriteln $2 }
            | 'readln(' ListParms ')' { AbsPascal.PListInstructionReadln $2 }
ListParms :: { [Parms] }
ListParms : {- empty -} { [] }
          | Parms { (:[]) $1 }
          | Parms ',' ListParms { (:) $1 $3 }
Parms :: { Parms }
Parms : String { AbsPascal.PWritelnParams $1 }
Parts :: { Parts }
Parts : Constants Types Vars FuncsProcs { AbsPascal.PPart $1 $2 $3 $4 }
Constants :: { Constants }
Constants : {- empty -} { AbsPascal.PPartConstEmpty }
          | 'const' ListConst { AbsPascal.PPartConst $2 }
ListConst :: { [Const] }
ListConst : {- empty -} { [] }
          | Const { (:[]) $1 }
          | Const ';' ListConst { (:) $1 $3 }
Const :: { Const }
Const : Id '=' Val { AbsPascal.PListConst $1 $3 }
Val :: { Val }
Val : Integer { AbsPascal.PValInteger $1 }
    | Double { AbsPascal.PValDouble $1 }
    | String { AbsPascal.PValString $1 }
    | Char { AbsPascal.PValChar $1 }
Types :: { Types }
Types : {- empty -} { AbsPascal.PPartTypesEmpty }
      | 'type' ListListTypes { AbsPascal.PPartTypes $2 }
ListListTypes :: { [ListTypes] }
ListListTypes : {- empty -} { [] }
              | ListTypes { (:[]) $1 }
              | ListTypes ';' ListListTypes { (:) $1 $3 }
ListTypes :: { ListTypes }
ListTypes : Id '=' Type { AbsPascal.PListTypes $1 $3 }
Type :: { Type }
Type : '(' ')' { AbsPascal.PTypeEnum }
     | '..' { AbsPascal.PTypeSubRange }
     | '^' Id { AbsPascal.PTypePointer $2 }
     | 'array' '[' ']' 'of' { AbsPascal.PTypeArray }
     | 'record' 'end' { AbsPascal.PTypeRecord }
     | Id { AbsPascal.PTypeIdentifier $1 }
Vars :: { Vars }
Vars : {- empty -} { AbsPascal.PPartVarsEmpty }
     | 'var' ListListVars { AbsPascal.PPartVars $2 }
ListListVars :: { [ListVars] }
ListListVars : {- empty -} { [] }
             | ListVars { (:[]) $1 }
             | ListVars ';' ListListVars { (:) $1 $3 }
ListVars :: { ListVars }
ListVars : ListListId ':' Id { AbsPascal.PListVars $1 $3 }
ListListId :: { [ListId] }
ListListId : {- empty -} { [] }
           | ListId { (:[]) $1 }
           | ListId ',' ListListId { (:) $1 $3 }
ListId :: { ListId }
ListId : Id { AbsPascal.PListId $1 }
FuncsProcs :: { FuncsProcs }
FuncsProcs : {- empty -} { AbsPascal.PPartFuncsProcs }
{

returnM :: a -> Err a
returnM = return

thenM :: Err a -> (a -> Err b) -> Err b
thenM = (>>=)

happyError :: [Token] -> Err a
happyError ts =
  Bad $ "syntax error at " ++ tokenPos ts ++ 
  case ts of
    [] -> []
    [Err _] -> " due to lexer error"
    _ -> " before " ++ unwords (map (id . prToken) (take 4 ts))

myLexer = tokens
}

